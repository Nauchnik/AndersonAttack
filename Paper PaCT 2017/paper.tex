% This template has been tested with LLNCS DOCUMENT CLASS -- version 2.20 (24-JUN-2015)

%"runningheads" enables:
%  - page number on page 2 onwards
%  - title/authors on even/odd pages
%This is good for other readers to enable proper archiving among other papers and pointing to content.
%Even if the title page states the title, when printed and stored in a folder, when blindly opening the folder, one could hit not the title page, but an arbitrary page. Therefore, it is good to have title printed on the pages, too.
\documentclass[runningheads,a4paper]{llncs}[2015/06/24]

%Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as "Abstract." -> "Abstract" or "Fig." -> "Figure") when using `english`, but not when using the other 2.
\usepackage[english]{babel}

%better font, similar to the default springer font
%cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
\usepackage[%
rm={oldstyle=false,proportional=true},%
sf={oldstyle=false,proportional=true},%
tt={oldstyle=false,proportional=true,variable=true},%
qt=false%
]{cfr-lm}
%
%if more space is needed, exchange cfr-lm by mathptmx
%\usepackage{mathptmx}

\usepackage{graphicx}


%% If you need packages for other papers,
%% START COPYING HERE

%extended enumerate, such as \begin{compactenum}
\usepackage{paralist}

\usepackage{amsmath}
%put figures inside a text
%\usepackage{picins}
%use
%\piccaptioninside
%\piccaption{...}
%\parpic[r]{\includegraphics ...}
%Text...

%Sorts the citations in the brackets
%It also allows \cite{refa, refb}. Otherwise, the document does not compile.
%  Error message: "White space in argument"
\usepackage{cite}

\usepackage[T1]{fontenc}
\usepackage{cmap}

%for demonstration purposes only
\usepackage[math]{blindtext}

%for easy quotations: \enquote{text}
\usepackage{csquotes}

%enable margin kerning
\usepackage{microtype}

%tweak \url{...}
\usepackage{url}
\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
%DO NOT ACTIVATE -> prevents line breaks
%\makeatletter
%\def\Url@twoslashes{\mathchar`\/\@ifnextchar/{\kern-.2em}{}}
%\g@addto@macro\UrlSpecials{\do\/{\Url@twoslashes}}
%\makeatother

%diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
%slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\usepackage{diagbox}

%required for pdfcomment later
\usepackage{xcolor}

% new packages BEFORE hyperref
% See also http://tex.stackexchange.com/questions/1863/which-packages-should-be-loaded-after-hyperref-instead-of-before

%enable hyperref without colors and without bookmarks
\usepackage[
%   pdfauthor={},
%   pdfsubject={},
%   pdftitle={},
%   pdfkeywords={},
   bookmarks=false,
   colorlinks=true,
   allcolors=black,
   pdfstartview=Fit,
   breaklinks=true,
]{hyperref}
%enables correct jumping to figures when referencing
\usepackage[all]{hypcap}

%enable nice comments
\usepackage{pdfcomment}
\newcommand{\commentontext}[2]{\colorbox{yellow!60}{#1}\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\newcommand{\commentatside}[1]{\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}

%compatibality with packages todo, easy-todo, todonotes
\newcommand{\todo}[1]{\commentatside{#1}}
%compatiblity with package fixmetodonotes
\newcommand{\TODO}[1]{\commentatside{#1}}

%enable \cref{...} and \Cref{...} instead of \ref: Type of reference included in the link
\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \cref
\crefname{section}{Sect.}{Sect.}
\Crefname{section}{Section}{Sections}

\usepackage{xspace}
%\newcommand{\eg}{e.\,g.\xspace}
%\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }

%introduce \powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\DeclareFontFamily{U}{MnSymbolC}{}
\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\DeclareFontShape{U}{MnSymbolC}{m}{n}{
    <-6>  MnSymbolC5
   <6-7>  MnSymbolC6
   <7-8>  MnSymbolC7
   <8-9>  MnSymbolC8
   <9-10> MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\DeclareMathSymbol{\powerset}{\mathord}{MnSyC}{180}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


%% END COPYING HERE


\begin{document}

\title{Implementation of a Brute Force Attack on A5/1 Cryptographical
Algorithm in a GPU-based Volunteering Computing Project}
%If Title is too long, use \titlerunning
\titlerunning{A5/1 Brute Force on GPU}

%Single insitute
\author{Bulavintsev V. \and Semenov A. \and Zaikin O.}
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}
\institute{Matrosov Institute for System Dynamics and Control Theory of
Siberian Branch of Russian Academy of Sciences
(ISDCT SB RAS)}

%Multiple insitutes
%Currently disabled
%
\iffalse
%Multiple institutes are typeset as follows:
\author{Firstname Lastname\inst{1} \and Firstname Lastname\inst{2} }
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}

\institute{
Insitute 1\\
\email{...}\and
Insitute 2\\
\email{...}
}
\fi
			
\maketitle

\begin{abstract}
We present an advanced brute force attack on the A5/1 cryptoalgorithm,
	that is still broadly used in modern GSM networks. We use a
	well-known idea introduced by R.Anderson more than 20 years ago
	to greatly reduce the search space. The primary contribution of
	this article is the implementation of the Anderson's attack on a GPU platform
	with the bitslice technique. The preliminary estimates of the
	attack's speed showed that, with the use of a GPUs processing power, 
	the attack could be conducted in the real
	time on a modern computer cluster or in a volunteer computing
	project. To verify our estimates with the use of BOINC technology 
	we concieved the specialized volunteering computing project 
	and executed our variant of Anderson's attack within it. In the
	7 days the project lasted, 10 A5/1 cryptanalysis problems were
	solved. The results presented in this work provide yet another
	proof of A5/1's cryptographical weakness that make it totally
	unsuitable for transmission of any kind of sensitive data
	through modern GSM networks.

\end{abstract}

\begin{keywords}
A5/1 algorithm, brute-force cryptanalysis, GPU, volunteering computing
\end{keywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\blindtext\todo{Refine me}

A5/1 algorithm is a keystream generator with key length of 64 bits. It is used
to encrypt voice and SMS traffic in 2nd generation ("2G") GSM networks. 3rd
generation GSM networks accept 2G communication protocol for backward
compatibility. A practice of sending voice traffic through 2G protocols in 3G
networks to conserve bandwith and increase service availability is widely
adopted among mobile phone operators. \todo{Can't find source} A widely adopted
practice among mobile operators is to still use 2G protocols to route voice
traffic even in 3rd generation GSM networks.

One can name A5/1 as one of the most publicly recognized cryptographical
algorithms, along with RSA and DES, it's discussion reaching far beyond the
borders of professional cryptographers community. For example, article
\cite{WASHPOST} publicly examines NSA's ability to efficiently decrypt A5/1.
So, in this article we won't touch on the details of A5/1's creation history
and the reasons of it's rise as the world's 'de facto' mobile communication
standard. Milestones in cryptanalysis of A5/1 would be briefly outlined in
Related Works section.

Among all the differrent methods of A5/1 cryptanalysis we distinguish those
which were realized in practice and allowed to reliably conduct the
cryptanalysis procedure on an non-weakened variant of algorithm. Apparently,
the first such attack was performed in 2008 with the help of the special
FPGA-based computational platform COPACOBANA\cite{COPAC_1}. In 2009 distributed
algorithms for boolean satisfiability (SAT) were used to solve several
cryptanalysis instances of stock A5/1 in a specialized grid system 'BNB-Grid'
\cite{TRUDY_ISA}. These results were further improved in 2011 \cite{SZBP}. By
the end of 2009 the 'A5/1 Cracking Project' had published rainbow tables
\cite{RAINBOW} for A5/1. Provided with 8 bursts (912 bits) of keystream these
tables allowed to find the secret key in less than a minute with more than 85\%
probabilty. Despite the huge (over 2 Tb) size, to this day these rainbow tables
provide the most practical method of A5/1 cryptanalysis.  It's main shortcoming
is that the probability of success is significantly less than 100\%. Meanwhile,
the growth of computational power of GPUs and FPGAs made practical the attack
based on reduction of search space from $2^64$ to $2^53$, which was described
by R.  Anderson in 1994. As was mentioned earlier, FPGA-based variant of the
Anderson's attack was already performed in 2008 by COPACOBANA creators. So, the
primary goal of our work is to demonstrate the viability of GPU-based variant
of the attack. Let us note that GPUs are much easier to operate than FPGAs, and
the former belong to the class of consumer-grade devices and could be found in
any modern PC, while the latter belong to the class of specialized equipment.
With the usage of the BOINC software platform \cite{BOINC_C}, this qualities of
GPUs allowed us to implement the attack in the form of a volunteering computing
project using idle computational capabilites of the project members home PCs.
Our estimates of attack's speed were based on our previous
work\cite{BUL_SEM_2016}.

Let's make a brief outline of the article's contents. In \Cref{sec:alg} we
describe the A5/1 algorithm along with some advanced brute-force attacks on it.
\Cref{sec:bitslc} introduces bit-slicing technique and goes through important
details of implementing the Anderson's attack with it. \Cref{sec:boinc}
provides a look into the internal organization of the volunteering project we
created for conducting the attack with GPUs. \Cref{sec:history} contains the
retrospective of A5/1 cryptanalysis works related to our study.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A5/1 algorithm and some attack on it}\label{sec:alg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A5/1 keystream generator consists of 3 linear feedback shift registers (LFSRs)
\cite{MENEZES}, defined by the following primitive polynomials:

\begin{gather*} 
	X^{19}+X^{18}+X^{17}+X^{14}+1, LFSR1;
	\\X^{22}+X^{28}+1, LFSR2;
	\\X^{23}+X^{22}+X^{21}+X^{8}+1, LFSR3.
\end{gather*}

The illustration of A5/1 generator's work scheme can be seen at
\cref{fig:a5gen}.

\begin{figure}
	\includegraphics[width=\linewidth]{./a51.png} 
	\caption{A5/1 generator work scheme} 
	\label{fig:a51gen} 
\end{figure}

The outputs of LFSRs are mixed with linear function, which provides the perfect
corellation immunity. Non-linearity of the equations is achieved by clocking
the registers asynchronously - for each clocking of the whole generator any of
the 3 registers could be clocked or it could retain it's current state.
Register with index $j \in \{1,2,3\}$ will be clocked if the following boolean
function $\chi_j$ becomes 1:

\begin {gather*}
\chi_j = (b_j \equiv majority(b_1,b_2,b_3)); 
\\majority(A,B,C)=(A \wedge B) \vee (A \wedge C) \vee (B \vee C).
\end{gather*}

Here $b_1,b_2,b_3$ denote clocking bits marked at \cref{fig:a5gen} by black
wedges. Conversely, if at some moment $\chi_j=0$, LFSR $j$ won't clock (it will
remain in it's last state).

Generator A5/1 is used in the GSM protocol for high-speed encryption of large
volumes of information with the short secret key. The whole process is split
into 'sessions' about 3,5 hours long. Each session uses it's own 'session key'.
We won't touch on the topic of specialized protocols used in GSM networks to
build and transfer the session key.

Along the message data, GSM protocol sends error correction data for the
message. The message complete with error correction data constitutes a 456 bits
long 'frame', which is further broken down into 4 'bursts' of 114 bits. The
bursts are than encrypted and send over the air. To encrypt a burst the A5/1
generator is initialized with the 64-bit 'local key', that is built using
session key and a natural number called 'the frame number' (FN). After the
encryption of one burst is complete, the frame number is increased by 1. When
FN overflows, the session ends and a new session is initialized (hence the 3,5
session length). FN is always known from the open data transmitted over the
network. 

If the message length is less than 23 bytes, the message would be filled with
fixed pattern padding to 23 bytes. Some GSM technical messages used during the
voice call are fixed length and always padded. As padding is always the same,
and it is encrypted by some local key, we got a typical plain text attack
scenario at hand \cite{MENEZES}. Indeed, the padding plays the role of the
known plaintext, allowing the attacker to get the corresponding keystream
fragment. This vulnerability allows the attacker to get no less than two frames
(912 bits) of the keystream. It was demonstrated in \cite{UNKN1} that the
knowledge of even one local key and FN is enough to efficiently restore the
session key, which makes the decryption of the whole session possible.


The described vulnerability of GSM protocol allows to build some successful
attacks on it, based on the idea of 'advanced brute force'. In particular, the
large-scale preprocessing made possible the creation of the rainbow tables,
which, provided 8 bursts of keystream, allows to determine the session key with
probability in less than a minute with $>85\%$ probability. The tables take
about 2Tb of disk space. This attack is presented in detail in \cite{RAINBOW},
and still stands among the most practical ones. Instead, we will focus on the
idea of an attack that was suggested by Ross Anderson in 1994 in a small essay
on the A5/1 cryptographic strength \cite{COPAC}. Next we describe the essence
of the Anderson's attack.


\begin{figure}
	\includegraphics[width=\linewidth]{./a51and.png} 
	\caption{The set of guessing bits used in Anderson's attack (greyed out).}
	\label{fig:a51and}
\end{figure}


Anderson's attack is a typical example of a 'guess and determine attack' (see
\cite{BARD}). Suppose we know the bits filling the 1st and the 3rd LFSR, and
bits of the 2nd LFSR from the beginning of the register to the clocking bit
(bits 31 to 41, see \cref{fig:a51and}). Next suppose we know 64 bits of the
keystream. Now, as was shown by R. Anderson, 11 unknown bits of the 2nd LFSR
could be figured out without any additional guesses. This happens because the
clocking bits are known (and so is the clocking schedule for the next 11
clockings of the 2nd LFSR), and known are 2 out of 3 XOR-ed LFSR output bits
and the result of the XOR operation (from the keystream). Therefore, one can
efficiently work out the unknown bits of the LFSR 2 one by one, by clocking the
generator and applying XOR operation to corresponding keystream bits and output
bits of LFSRs 1 and 3.

The description of the algorithm of determination of unknown 11 bits of LFSR 2
provided above makes obvious the possibility to mount a brute force attack on
the A5/1 generator over the search space of $2^{53}$. The simplicity of the
algorithm provides an opportunity to implement it on a specialized
computational architecture. One such implementation was built with FPGAs by
authors of \cite{COPAC_1}. In the following sections we describe our
implementation of this attack for a modern GPU.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation of the Anderson's Attack in bit-slicing
technique}\label{sec:bitslc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The effeciency of a brute force attack is defined by two parameters: the speed
of checking of the key candidates and the size of the search space. R.
Anderson's idea described above give us a $$2^{53}$$ search space for the A5/1
generator. Instead of using the 'naive' implementation of A5/1 generator, to
speed up the key candidates checking procedure one can opt to use more
sophisticated alternatives. We evaluated the performance of two different fast
implementations of A5/1 generator in \cite{PAVT_2016}. The first one was based
on an idea of precomputation of the states of the registers LFSR 1-3, and
keeping the states in RAM, to use them as the look-up tables. This approach
demonstrated a considerable speed-up against 'naive' implementation. A similiar
method of precomputation of LFSRs was described in \cite{BSW}. However, in
\cite{PAVT_2016} we found its performance inferior to the second
implementation, that is based on the 'bit-slicing technique'. Next we briefly
describe the idea of this technique, and it's application to Anderson's attack.

Modern general-purpose computational architectures are suboptimal for
implementation of many algorithms. The last operate with bits, while CPUs and
GPUs typically operate with 32-256 bit words. As the result of this
discrepancy, the 'naive' implementation of a cryptographical algorithm won't be
fully using the platform's computational resources. For example, to conduct a
'addition modulo 2' (XOR) operation on 2 boolean arguments, a modern CPU will
position the arguments values into the lowest bits of two 32-bit
general-purpose register (GPR), perform the computation and write the result
into the third 32-bit GPR. In effect, 31 out of 32 bits of GPRs stay idle
during this operation. This problem could be solved by using bitwise operations
that work on GPRs like on boolean vectors - digit by digit. A cryptographical
algorithm could be oftentimes represented as a logical scheme built with the
basic logical gates. Coupled with bitwise operations, this representation
allows the computational platform to apply the algorithm to as many sets of
data, as there are bits in it's GPR (e.g. the platform's register capacity).
This method is called 'SIMD within a register' or the 'bit-slicing' technique.
The first mention of bit-slicing technique applied to cryptographical problem
belongs, seemingly, to E.Biham \cite{BIT_SL}.

Now we describe the main idea of the bit-slicing technique. Consider an
arbitrary total boolean function

\begin{gather*} 
	f:\{0,1\}^n\rightarrow\{0,1\}
\end{gather*}

This function can be represented in the form of the Boolean circuit $C(f)$ over
some complete basis $B$. A common example of such basis is
$B=\{\land,\lor,\neg\}$, but we'll use the basis $B=\{\land,\lor,\neg,\oplus\}$
instead, since it better fits our goals.

Now consider the problem of calculating the arbitrary total boolean function
$f:\{0,1\}^n\rightarrow\{0,1\}$ over all $2^n$ possible inputs. For each input
$X\in\{0,1\}^n$ one can calculate the value of $f$ as a superposition of the
basis functions, according to the scheme $C(f)$. We can now select at least one
fixed order of calculation of basis functions from $C(f)$, that results in
getting the value of $f$. Let $m$ be the number of internal nodes in $C(f)$.
Assuming that the calculation of one basis function takes one processor
instruction, the computation of $f$ over all inputs from $\{0,1\}^n$ will take
$m\cdot2^n$ instructions.

A computational architecture that, in a single instruction execution,
calculates many copies of the same function over many different memory cells,
is called the 'single instruction, multiple data' (SIMD) architecture. When a
modern computational device executes a bitwise logical instruction over its
GPRs, it effectively acts as a SIMD device, individual bits of GPRs playing the
role of the individual memory cells of a SIMD device. The calculation order of
functions in the scheme $C(f)$ always stays the same. This makes it possible to
compute this functions over as many inputs, as there are bits in the device's
GPR.  In effect, if $D$ is the device's GPR capacity, we can simultaneously
walk $D$ instances of the scheme $C(f)$, effectively calculating the value of
$f$ for inputs $X_1,...,X_D$.

Let's examine the arbitrary basis function $g$ with arity 2, and the
corresponding internal node of the scheme $C(f)$. We denote it as $G(x_1,x_2)$,
meaning that it has a single output and two inputs, which values are determined
by boolean variables $x_1,x_2$. Next, collate $g$ with three GPRs denoted
$R_1(g),R_2(g),R_3(g)$, each of which is comprised of $D$ single-bit memory
cells, filled in the following way: 
\begin{itemize} 
\item Register $R_1$ contains $D$ values of the variable $x_1$, corresponding
 to $X_1,...,X_D$; 
\item Register $R_2$ contains $D$ values of the variable $x_2$, corresponding
 to $X_1,...,X_D$;
\item Register $R_3$ contains $D$ values of the function $g$, corresponding to
 matching values of $X_1,...,X_D$.
\end{itemize}
Suppose that all $D$ instances of values of $g$ (matching the corresponding
values of $x_1$ and $x_2$) can be computed as a result of a single bitwise
instruction applied to register $R_1(g),R_2(g)$, while their result is put into
register $R_3(g)$.  If this fact is holding true for every basis function in
the scheme $C(F)$, the computation of $f$ for every input from $\{0,1\}^n$ will
require $m\cdot\frac{2^n}{D}$ instructions. This is the key idea of the
bit-slicing technique \cite{fig:bitsl}.


\begin{figure} \includegraphics[width=\linewidth]{./bitslice.png}
	\caption{Simultaneous computation of $D$ instances of scheme $C(f)$ with
	bit-slicing technique} \label{fig:a51gen} 
\end{figure}

We will call the process of computation of the function $f$ on a single input
from $\{0,1\}^n$ a "thread", by analogy with the computational threads in a
SIMD device. So, with the use of bit-slicing technique, it takes $m$
instructions to complete the computation of $D$ threads.

Now we describe the details of bit-slicing implementation of the A5/1
generator. Suppose that a computational device is able to calculate $D$
instances of any function from the basis $B=\{\land,\lor,\neg,\oplus\}$. Each
of $n\in\{1,...,64\}$ cells of LFSR 1-3 gets a matching word $W_n\in\{0,1\}^D$:

\begin{gather*} 
	LFSR1:W_1,...,W_{19}; 
	\\LFSR2:W_{20},...,W_{42}; 
	\\LFSR3:W_{43},...,W_{64}.
\end{gather*}

In a bit-slicing technique, the shift of the LFSR register (LFSR 1 in this
example) will take the following form: 
\begin{gather*} 
	W`_1=W_{19} \oplus W_{18} \oplus W_{17} \oplus W_{14}, 
	\\W`=W_{n-1}, n \in \{2,...,19\},
\end{gather*}
where $\oplus$ is the bitwise addition modulo 2 of boolean vectors of length
$D$ operator. The calculation of the keystream bit will look like:
\begin{gather*} 
	W_{out}=W_{19} \oplus W_{41} \oplus W_{64}.
\end{gather*}

The conditional clocking is somewhat more complex to implement in a bit-slicing
technique. First, to know if the LFSRs should be shifted or not, one needs to
calculate the corresponding clocking flags $F_1,F_2,F_3$ using the majority
function: 
\begin{gather*} 
	W_{maj}=maj(W_8,W_{30},W_{52})=(W_9 \wedge W_{30}) \vee (W_9 \wedge W_{52})
	\vee (W_{30} \vee W_{52}), \\F_1 = W_9 \oplus {\neg W_{maj}}, \\F_2 =
	W_{30} \oplus {\neg W_{maj}}, \\F_3 = W_{52} \oplus {\neg W_{maj}},
\end{gather*} 
(all operations are bitwise operations on the vector of the length $D$).

To implement the conditional clocking of a LFSR one can use the bitwise
counterpart of the "bitselect" function of arity 3: 
\begin{gather*} a,b,c \in \{0,1\}; \\ BS(a,b,c) = \left\lbrace
	\begin{array}{ll} b,a=1, \\ c,a=0.
	\end{array} \right.
\end{gather*} 

If the computational architecture lacks the hardware implementation of this
function, it can be emulated with the usage of the standard bitwise functions
corresponding to the functions of the basis $B$ (example for LFSR 1):
\begin{gather*} BS(a,b,c) = (a \wedge b) \vee (\neg a \wedge c).
\end{gather*}

Clocking the LFSR 1 with the use of $BS(a,b,c)$ and corresponding flag $F_1$
looks the following way:
\begin{gather*} 
	W'_1 = BS(F_1, (W_{19} \oplus W_{18} \oplus W_{17} \oplus W_{14}), W_1);
	\\W'_n = BS( F_1, W_{n-1}, W_n), n \in \{2,..,19\}.
\end{gather*}

Some important details about the bit-slicing implementation of the Anderson's
attack should be covered still. The Anderson's attack follows 2 stages:
\begin{enumerate} 
	\item Calculating the values of 11 bits of LFSR 2 lying left of the
	 clocking bit with the information from the remaining 53 bits (guessed) and
		the keystream (known).
	\item Clocking the generator as normal to check if the guessed filling of
	 the generator matches the known keystream.
\end{enumerate}

The irregular clocking of the A5/1 generator makes it generally impossible to
predict how many clockings of the whole generator (bits of keystream) would be
needed to shift LFSR 2 11 times to complete the Stage 1 of the attack.
Therefore, we again put to use the bitselect function to implement the split of
the attack into 2 stages. Since each individual thread should be able to stay
in a stage and advance to the next stage independent of other threads, we
introduce the special boolean vector $\phi = (\phi_1,...,\phi_D)$, called the
"attack stage flag". The thread with number $i, i \in \{1,...,D\}$ being in the
Stage 1 of the attack corresponds to $\phi_i = 0$, and the Stage 2 of the
attack corresponds to $\phi_i=1$. Let $y_1,...,y_{64}$ be the bits of the
keystream analyzed. Now the clocking of the LFSR 2 considers the stage of the
attack through the usage of the attack stage flag: \begin{gather*} W^\ast_{41}
	= BS(\phi, W_{41},(y \oplus W_{19} \oplus W_{64}));\\W'_{20} =
	BS(F_2,(W^\ast_{41} \oplus W_{40}), W_{20});\\W'_n = BS(F_2,W_{n-1},W_n), n
	\in \{20,...,41\}. 
\end{gather*}

Here $W^\ast_{41}$ is a helper vector holding temporary data. $y$ is the
current bit of the keystream, in the form of a vector consisting of $D$ copies
of $k$-th bit of the keystream. In effect, Stage 1 of the attack's goal is to
calculate the last bit of the LFSR 2 from known keystream bits and known
(guessed) last bits of the LFSRs 1 and 3. At the Stage 2 the last bit of the
LFSR 2 is known and the whole generator scheme is clocked as normal. For the
$i$-th thread the attack stage flag $\phi_i$ is set to 1 after the thread's
instance of LFSR 2 was shifted 11 times. To count the number of LFSR 2 shifts
on a per-thread basis, the bit-slicing implementation of an incremental counter
is used.

The Anderson's attack algorithm described above was realized on an NVIDIA GPU
with the use of CUDA SDK 8.0 \cite{CUDA}. The comparison of the performance of
a GPU to a CPU in execution of bit-slicing and LFSR precomputation-based
\cite{BSW} implementations of Anderson's attack is shown in
\cite{tab:gpuspeed}.


\begin{table} \caption{(LOP3.LUT is a special instruction that implements
	arbitrary bitwise arity 3 functions in hardware. We use it as a substitute
	for the "bitselect" instruction.)} 
	\label{tab:gpuspeed} Performance of the different implementations of the
	Anderson's attack (search space is $2^{53}$) on a CPU and a GPU, measured
	in millions of key checks per second.  
	\begin {center} \begin{tabular} {| l | l | l | l |} \hline Computational
		device & Bit-slicing & LFSR precomputation \cite{BSW} \\ \hline CPU
		Intel Core I7 930 & 37 & 7 \\ \hline GPU NVIDIA GTX 1050 Ti & 9180 &
		483 \\ \hline GPU NVIDIA GTX 1050 Ti (LOP3.LUT) & 11950 & - \\ \hline


	\end{tabular}
\end {center}
\end{table}

Data provided in the \Cref{tab:gpuspeed} tells us that even one mid-range
consumer GPU is enough to make the Anderson's attack run time practical (it
will take around 250 hours). A modern computational cluster outfitted with GPUs
will complete the attack in mere minutes or less. The Anderson's attack's
advantage over the rainbow-tables attack \cite{RAINBOW} is the former's ability
to restore the secret key from 64 bits of keystream with the 100\% probability.
It's advantge over the attack described in \cite{COPAC_1} is in a usage of a
consumer-grade off-the-shelf hardware.




Winery~\cite{Winery} is graphical \commentontext{modeling}{modeling with one \enquote{l}, because of AE} tool.

\begin{figure}
Simple Figure
\caption{Simple Figure}
\label{fig:simple}
\end{figure}

\begin{table}
\caption{Simple Table}

\label{tab:simple}
Simple Table
\end{table}

cref Demonstration: Cref at beginning of sentence, cref in all other cases.

\Cref{fig:simple} shows a simple fact, although \cref{fig:simple} could also show something else.

\Cref{tab:simple} shows a simple fact, although \cref{tab:simple} could also show something else.

\Cref{sec:intro} shows a simple fact, although \cref{sec:intro} could also show something else.

Brackets work as designed:
<test>

The symbol for powerset is now correct: $\powerset$ and not a Weierstrass p ($\wp$).

\begin{inparaenum}
\item All these items...
\item ...appear in one line
\item This is enabled by the paralist package.
\end{inparaenum}

``something in quotes'' using plain tex or use \enquote{the enquote command}.

\section{Conclusion and Outlook}

\subsubsection*{Acknowledgments}
...

In the bibliography, use \texttt{\textbackslash textsuperscript} for ``st'', ``nd'', ...:
E.g., \enquote{The 2\textsuperscript{nd} conference on examples}.
When you use \href{https://www.jabref.org}{JabRef}, you can use the clean up command to achieve that.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs03}
\bibliography{paper}

All links were last followed on October 5, 2014.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
